/**
 * A board object, presumably created for each room.
 * Manages the pieces and allows for movement, checks if move is legal within
 * pieces' abilities.
 *
 * @public: move(), allows movement of one piece to another square
 *          takes following arguments:
 *          piece - a reference to the piece object that is to be moved
 *          moveFile - int that expects the number of files to move
 *          moveRank - int that expects the number of ranks to move
 *          returns:
 *          false if there is a piece obstructing the path
 */

var Square = require('square');
var Piece = require('../pieces');

var Board = function() {
    //Creates the grid
    var grid = [];
    //Fills up the grid with arrays of size 8
    for (var i = 0; i < 8; i++)
        grid[i] = new Array(8);


    //Initialize the board with squares and pieces
    for (var file = 1; file <= 8; file++)
        for (var rank = 1; rank <= 8; rank++) {
            switch (file) {
                // Fill with the white base row
                case 1:
                    switch (rank) {
                        case 1:
                        case 8:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.rook(1));
                            break;

                        case 2:
                        case 7:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.knight(1));
                            break;

                        case 3:
                        case 6:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.bishop(1));
                            break;
                        case 4:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.queen(1));
                            break;
                        case 5:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.king(1));
                    }
                    break;
                // Fill with the white pawn row
                case 2:
                    grid[file - 1][rank - 1] =
                        new Square(rank, file, new Piece.pawn(1));
                    break;

                // Fill with the black pawn row
                case 7:
                    grid[file - 1][rank - 1] =
                        new Square(rank, file, new Piece.pawn(0));
                    break;

                // Fill with the black base row
                case 8:
                    switch (rank) {
                        case 1:
                        case 8:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.rook(0));
                            break;

                        case 2:
                        case 7:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.knight(0));
                            break;

                        case 3:
                        case 6:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.bishop(0));
                            break;
                        case 4:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.queen(0));
                            break;
                        case 5:
                            grid[file - 1][rank - 1] =
                                new Square(rank, file, new Piece.king(0));
                            break;
                    }
                    break;

                // File 3 and 6 are initially under attack from pawns
                case 3:
                case 6:
                    grid[file - 1][rank - 1] =
                        new Square(rank, file, new Piece.empty(), true);
                    break;

                default:
                    grid[file - 1][rank - 1] =
                        new Square(rank, file, new Piece.empty());
            }
        }

    //Returns a map of all pieces on the board
    this.getPieces = function() {
        return grid.map(function(row) {
            return row.map(function(square) {
                return square.getPieceName();
            });
        });
    };

    //Returns the grid as an array of board IDs
    this.getGrid = function() {
        return grid.map(function(row) {
            return row.map(function(square) {
                return square.toString();
            });
        });
    };

    // Returns a specific square in the grid
    this.getGridSquare = function(file, rank) {
        return grid[file - 1][rank - 1];
    };
};



//Returns board for debug; will be removed, don't use
Board.prototype.toString = function() {
    return this.getGrid();
};
//Returns piecemap for debug; will be removed, don't use
Board.prototype.getPiecemap = function() {
    return this.getPieces();
};

// Returns the square at position file, rank
Board.prototype.getSquare = function(file, rank) {
    return this.getGridSquare(file, rank);
};

//Moves a piece on the board, returns false on illegal move, returns piece name
// otherwise
Board.prototype.move = function(piece, moveFile, moveRank) {
    var newFile = piece.getFile() - 1 + moveFile;
    var newRank = piece.getRank() - 1 + moveRank;

    //If moving the piece would move it out of bounds, return false
    if (newFile > 8 || newFile < 0 || newRank < 0 || newRank > 8)
        return false;

    this.grid[piece.getFile() - 1][piece.getRank() - 1] = new Piece(0);

    //If the new square contains a piece, unmap it
    var newSquare = this.grid[moveFile][moveRank];
    if (newSquare.getPiece().value !== 0)
        Piece.unmap(newSquare.getPiece());

    //Now let the square contain the new piece
    newSquare.setPiece(piece);
    //Now set the piece's new coordinates
    piece.setCoords(newRank, newFile);

    return piece.getName();
};

module.exports = Board;