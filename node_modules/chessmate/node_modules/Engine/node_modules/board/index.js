/**
 * A board object, presumably created for each room.
 * Manages the pieces and allows for movement, checks if move is legal within
 * pieces' abilities.
 *
 * @public: move(), allows movement of one piece to another square
 *          takes following arguments:
 *          piece - a reference to the piece object that is to be moved
 *          moveFile - int that expects the number of files to move
 *          moveRank - int that expects the number of ranks to move
 *          returns:
 *          false if there is a piece obstructing the path
 */

var Square = require('square');
var pieces = require('../pieces');

var Board = function(Piece) {
    if (Piece === undefined)
        Piece = new pieces();
    this.Piece = Piece;
    //Creates the grid
    var grid = [];
    //Fills up the grid with arrays of size 8
    for (var i = 0; i < 8; i++)
        grid[i] = new Array(8);


    //Initialize the board with squares and pieces
    for (var rank = 0; rank < 8; rank++)
        for (var file = 0; file < 8; file++) {
            var square;
            switch (rank) {
                // Fill with the white base row
                case 0:
                    switch (file) {
                        case 0:
                        case 7:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.rook(0, square));
                            break;

                        case 1:
                        case 6:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.knight(0, square));
                            break;

                        case 2:
                        case 5:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.bishop(0, square));
                            break;
                        case 3:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.queen(0, square));
                            break;
                        case 4:
                            var kingSquare = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = kingSquare;
                            kingSquare.setPiece(Piece.king(0, kingSquare));
                    }
                    break;
                // Fill with the white pawn row
                case 1:
                    square = new Square(8 - rank, file + 1,
                                                Piece.empty());
                    grid[7 - rank][file] = square;
                    square.setPiece(Piece.pawn(0, square));
                    break;

                // Fill with the black pawn row
                case 6:
                    square = new Square(8 - rank, file + 1,
                                                Piece.empty());
                    grid[7 - rank][file] = square;
                    square.setPiece(Piece.pawn(1, square));
                    break;

                // Fill with the black base row
                case 7:
                    switch (file) {
                        case 0:
                        case 7:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.rook(1, square));
                            break;

                        case 1:
                        case 6:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.knight(1, square));
                            break;

                        case 2:
                        case 5:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.bishop(1, square));
                            break;
                        case 3:
                            square = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = square;
                            square.setPiece(Piece.queen(1, square));
                            break;
                        case 4:
                            var kingSquare = new Square(8 - rank, file + 1,
                                                        Piece.empty());
                            grid[7 - rank][file] = kingSquare;
                            kingSquare.setPiece(Piece.king(1, kingSquare));
                            break;
                    }
                    break;

                // File 3 and 6 are initially under attack from pawns
                case 3:
                case 6:
                    grid[7 - rank][file] =
                        new Square(8 - rank, file + 1, Piece.empty(), true);
                    break;

                default:
                    grid[7 - rank][file] =
                        new Square(8 - rank, file + 1, Piece.empty());
            }
        }

    //Returns a map of all pieces on the board
    this.getPieces = function() {
        return grid.map(function(file) {
            return file.map(function(square) {
                return square.getPieceName() + square.getPieceColor();
            });
        });
    };

    //Returns the grid as an array of board IDs
    this.getGrid = function() {
        return grid.map(function(file) {
            return file.map(function(square) {
                return square.toString();
            });
        });
    };

    // Returns a specific square in the grid
    this.getGridSquare = function(file, rank) {
        return grid[rank - 1][file - 1];
    };
};

//Returns board for debug; will be removed, don't use
Board.prototype.toString = function() {
    return this.getGrid();
};
//Returns piecemap
    Board.prototype.getPiecemap = function() {
    return this.getPieces();
};

// Returns the square at position file, rank
Board.prototype.getSquare = function(file, rank) {
    return this.getGridSquare(file, rank);
};

//Moves a piece on the board, returns false on illegal move, returns piece name
// otherwise
Board.prototype.move = function(square, moveFile, moveRank) {
    var newSquare = this.getGridSquare(moveFile, moveRank);

    if (newSquare.getPieceName() !== ' ') {
        this.Piece.removePiece(newSquare.getPiece());
    }

    // Overwrite the piece at the new square's position
    newSquare.overwritePiece(square.getPiece());
    newSquare.getPiece().setSquare(newSquare);
    // Make the old square empty
    square.overwritePiece(this.Piece.empty());
};

module.exports = Board;