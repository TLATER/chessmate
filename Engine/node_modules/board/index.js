/*
 * A board object, presumably created for each room.
 * Manages the pieces and allows for movement, checks if move is legal within
 * pieces' abilities.
 *
 * @public: move(), allows movement of one piece to another square
 *          takes following arguments:
 *          piece - a reference to the piece object that is to be moved
 *          moveFile - int that expects the number of files to move
 *          moveRank - int that expects the number of ranks to move
 *          returns:
 *          false if there is a piece obstructing the path
 */

var Square = require('square');
var Piece = require('../pieces');

//Declaring a piece class here for testing until Yi gets going
//Constructor
var Piece = function(int) {
    //Please use a number that represents the piece's value
    this.value = int;
    //I propose using S for "Springer", in case we want to introduce fairy
    // figures (Nightrider)
    var name;
    if (int === 0)
        name = 'E';
    else
        name = 'S';

    this.getName = function() {
        return name;
    };
};
Piece.prototype.toString = function() {
    return this.getName();
};

var Board = function() {
    //Creates the grid
    var grid = [];
    //Fills up the grid with arrays of size 8
    for (var i = 0; i < 8; i++)
        grid[i] = new Array(8);
    //Creates squares to fill this grid
    for (var file = 0; file < 8; file++)
        for (var rank = 0; rank < 8; rank++) {
            if ((rank === 1 || rank === 8) && (file === 2 || file === 7))
                grid[file - 1][rank - 1] = new Square(rank, file, new Piece.rook();
            else
                grid[file - 1][rank - 1] = new Square(rank, file, new Piece(0));

            if (file == 0)
                switch (rank) {
                    case 0:
                        grid[file][rank]
                }
        }

    //Returns a map of all pieces on the board
    this.getPieces = function() {
        return grid.map(function(row) {
            return row.map(function(square) {
                return square.getPiecemap();
            });
        });
    };

    //Returns the grid as an array of board IDs
    this.getGrid = function() {
        return grid.map(function(row) {
            return row.map(function(square) {
                return square.toString();
            });
        });
    };
};
//Returns board for debug; will be removed, don't use
Board.prototype.toString = function() {
    return this.getGrid();
};
//Returns piecemap for debug; will be removed, don't use
Board.prototype.getPiecemap = function() {
    return this.getPieces();
};

//Moves a piece on the board, returns false on illegal move, returns piece name
// otherwise
Board.prototype.move = function(piece, moveFile, moveRank) {
    var newFile = piece.getFile() + moveFile;
    var newRank = piece.getRank() + moveRank;

    //If moving the piece would move it out of bounds, return false
    if (newFile > 8 || newFile < 0 || newRank < 0 || newRank > 8)
        return false;

    this.grid[piece.getFile()][piece.getRank()] = new Piece(0);

    //If the new square contains a piece, unmap it
    var newSquare = this.grid[moveFile][moveRank];
    if (newSquare.getPiece().value !== 0)
        Piece.unmap(newSquare.getPiece());

    //Now let the square contain the new piece
    newSquare.setPiece(piece);
    //Now set the piece's new coordinates
    piece.setCoords(newRank, newFile);

    return piece.getName();
};

module.exports = Board;